@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Guile-CV Reference Manual.
@c Copyright (C) 2016 - 2017 Free Software Foundation, Inc.
@c See the file guile-cv.texi for copying conditions.


@node Segmentation
@subsection Segmentation

The Guile-CV procedures and methods related to segmentation.

@subheading Procedures

@ifhtml
@indentedblock
@table @code
@item @ref{im-label}
@item @ref{im-label-channel}
@item @ref{im-label-all}
@item @ref{im-label-all-channel}
@c @item @ref{im-watershed}
@c @item @ref{im-watershed-channel}
@item @ref{im-canny}
@item @ref{im-canny-channel}
@end table
@end indentedblock
@end ifhtml


@anchor{im-label}
@anchor{im-label-channel}
@anchor{im-label-all}
@anchor{im-label-all-channel}
@deffn Procedure im-label image [#:con 8] [#:bg 'black]
@deffnx Procedure im-label-channel channel width height [#:con 8] [#:bg 'black]
@deffnx Procedure im-label-all image [#:con 8]
@deffnx Procedure im-label-all-channel channel width height [#:con 8]

Returns two values: a new GRAY image or GRAY channel, and the total
number of objects.

The @code{im-label} and @code{im-label-channel} procedures label
foreground objects in the binary @var{image}.  In the new image or
channel, 0.0 indicates a background pixel, 1.0 indicates that the pixel
belongs to object number 1, 2.0 that the pixel belongs to object number
2, etc.

The @code{im-label-all} and @code{im-label-all-channel} procedures label
all objects in the binary @var{image}, with no specific distinction for
any @emph{background value}. As a result, these two procedures will
label not only the continuous background, if any, but also any
hole(s). As an example, they are used by @ref{im-fill-holes}, defined in
the module @code{(cv morphology)}, which you may have a look at for a
better understanding of how it works.

Two pixels belong to the same object if they are neighbors.  By default
the algorithm uses 8-connectivity to define a neighborhood, but this can
be changed through the keyword argument @var{#:con}, which can be either
4 or 8.

@ifnottex
@image{images/pp-17-bf,,,pp-17-bf,png}
@image{images/pp-17-label,,,pp-17-bf-label,png}
@image{images/pp-17-label-all,,,pp-17-bf-label-all,png}

Here above, left being the original image, you can see the difference
between @code{im-label} (1 object) and @code{im-label-all} (6 objects).
Note that we had to run @code{im-threshold} on the original image first
(all labeling procedures take a binary image (or channel) as their
mandatory argument), for the record, we used @code{128} as the threshold
value.
@end ifnottex
@end deffn


@c @anchor{im-watershed}
@c @anchor{im-watershed-channel}
@c @deffn Procedure im-watershed image
@c @deffnx Procedure im-watershed-channel channel width height

@c Returns a new image or channel.
@c @end deffn


@anchor{im-canny}
@anchor{im-canny-channel}
@deffn Procedure im-canny image @
       [#:sigma 1.0] [#:threshold 0.0] [#:marker 255.0]
@deffnx Procedure im-canny-channel channel width height @
       [#:sigma 1.0] [#:threshold 0.0] [#:marker 255.0]
@cindex Edge Detection

Returns a new image or channel.

Detect and mark edges using a @uref{@value{UCANNYEDGE}, Canny Edge
Detector} algorithm: (a) compute the @var{image} Gaussian gradient using
@var{sigma}, (b) remove edges whose strength is below @var{threshold},
then for all remaining edges, (d) remove the non-local maxima
(@uref{@value{UEDGETHINNING}, edge thinning}) and (e) set their
intensity using @var{marker}.

@ifnottex
@image{images/edx,,,edx,png}
@image{images/edx-canny-s1.0-t0.0-m255.0,,,edx-canny-s1.0-t0.0-m255.0,png}
@image{images/edx-canny-s1.0-t8.0-m255.0,,,edx-canny-s1.0-t8.0-m255.0,png}
@image{images/edx-canny-s1.5-t8.0-m255.0,,,edx-canny-s1.5-t8.0-m255.0,png}
@image{images/edx-canny-s1.0-t8.0-m96.0,,,edx-canny-s1.0-t8.0-m96.0,png}


Here above, left being the original @code{tif} image@footnote{Actually,
all images displayed in the documentation are @code{png} images, though
all described @code{im-canny} calls where performed on the original
@code{tif} image. This is because in Guile-CV, all images are 32bit
float images, and when saved as @code{tif}, all values are preserved (as
opposed to being normalized): however, most viewers do not handle
floating point pixel values (they donÂ´t know how to scale the values,
which may be negative, fractional...). In order to show the results in
the documentation, even though all computations of this example were
made upon the original @code{tif} image, they were saved to @code{png}
(which normalize all pixel values to [0 255].).}, you can see the
difference between @code{im-canny} called using the default values, then
using @var{#:threshold 8}, and finally both @var{#:sigma 1.5} and
@var{#:threshold 8}. The last example is an illustration of the use of
@code{#:marker 96.0}@footnote{Note that in order to show the result in
the documentation, we had to manually set one pixel of one of the edges
to 255.0: this is because, just as we explained in the previous
footnote, to be able to display the image in the documentation, we had
to save the image as @code{png}, which does normalize all values: if you
do not set one of the pixels of one edge to 255.0, all markers values
would be normalized to 255.0, there by loosing the original marker
value.}.
@end ifnottex
@end deffn
